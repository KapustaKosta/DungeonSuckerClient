# Dungeon sucker
*2024*
Авторы:
Кирилл Довганюк, Б05-311
Константин Стариков, Б05-311
Илья Капуткин, Б05-311

### Краткое описание игры
Dungeon Sucker — это пошаговый рогалик с элементами кооперативного прохождения лабиринта, где игроки объединяются для исследования комнат, борьбы с врагами и победы над боссами.

### Что из себя представляет игра на данный момент?
На данный момент игра почти готова. Реализовано:
1. Консольная версия боя
2. UI версия боя
3. UI передвижения по карте
4. Базовый интерфейс игры: окно с картой, окно инвентаря и основное окно с боем 

Реализованные механики:
- Случайная генерация уровня
- Усиление врагов в зависимости от уровня и времени, прошедшего с момента захода в уровень
- Генерация различных типов оружий, имеющих различные характеристики
- Генерация сокровищ со случайными наградами
### Требование к ПО
 -  Java 11-18
Сторонние библиотеки:
- com.badlogic.gdx  
### Команды для сборки проекта
Для сборки должна быть установлена JDK от 11 версии до 18. Проект разработчиками проверяется только на JDK 17 версии, так что рекомендуется использовать её.
Итак:
1. Склонируйте проект на свой пк:
`git clone https://gitlab.akhcheck.ru/tp2024-projects/project-7.git`
2. Зайдите в папку с проектом
`cd project-7`
3. Откройте файл gradle.properties
`gedit gradle.properties`
4. Добавьте строчку
`org.gradle.java.home=путь до вашего JDK`
Например в моём случае это:
org.gradle.java.home=C\:\\Program Files\\Java\\jdk-17
5. Теперь введите следующую команду:
`gradlew desktop:build`

Проект должен собраться
### Команды для запуска проекта
Для запуска должна быть установлена JDK от 11 версии до 18. Проект разработчиками проверяется только на JDK 17 версии, так что рекомендуется использовать её.
Итак:
1. Склонируйте проект на свой пк:
`git clone https://gitlab.akhcheck.ru/tp2024-projects/project-7.git`
2. Зайдите в папку с проектом
`cd project-7`
3. Откройте файл gradle.properties
`gedit gradle.properties`
4. Добавьте строчку
`org.gradle.java.home=путь до вашего JDK`
Например в моём случае это:
`org.gradle.java.home=C\:\\Program Files\\Java\\jdk-17`
5. Теперь введите следующую команду:
`gradlew desktop:run`
Проект должен запуститься
### Как играть
Когда вы запускаете игру, вы оказываетесь в стартовой комнате. В ней можно нажимать только кнопку **change room**. Далее вы ходите по комнатам, нажимая change room, как только попадается комната с врагами, они должны у вас отрисовываться на экране. Если это так, то вы можете нажать кнопку **attack** и выбрать кого будете бить, заметьте что и вас тоже будут бить вражеские персонажи. Вы можете выбрать любой из трёх скиллов, чтобы бить врагов.
### Архитектура
Диаграмма вариантов использования представлена на картинке use-keyses.png.

UML диаграмма представлена на картинке uml.png. Классы разделены на три группы: геймплей, UI и сетевое взаимодействие.

Для отрисовки интерфейса хотелось сделать так, чтобы можно было выбирать, где именно он будет отрисовываться, в консоли или в окне приложения. Поэтому был создан интерфейс Drawable с методами drawInLibGDX и drawInConsole. Каждому объекту который должен рисоваться, нужно отнаследоваться от этого интерфейса и реализовать методы.
Создан класс Interface, являющийся интерфейсом пользователя. Интерфейс состоит из окон, поэтому создан класс Window, который является общим для всех окон. Окно определяется своей левой верхней точкой и своей правой нижней точкой на экране. Из них уже рассчитывается ширина и высота окна.
Пока что есть всего три окна - окно инвентаря, которое состоит из ячеек с оружием, также окон, 

Для сетевого взаимодействия используется протокол **TCP**, потому что игра пошаговая, из-за чего не требуется быстрая скорость обмена обмена пакетами, достаточно протокола, который будет гарантировать доставку каждого пакета.
Созданы интерфейсы Client и Server для TCP клиента и сервера.
Также есть класс для хранения заголовка пакета PacketHeader и класс для хранения пакета Packet.
Планируется использовать [Protobuf](https://protobuf.dev) для сериализации и десериализации  данных, передаваемых по сети.

В архитектуре часто используется паттерн **наблюдатель**, например, когда какой-то персонаж получает предмет (item), он вызывает метод getObtained у item'а, или когда теряет вызывает метод getLost.
Наблюдатель используется и для отрисовки. Методы drawInLibGDX и drawInConsole как бы подписываются на метод отрисовки интерфейса, а как эту отрисовку осуществлять классы определяют уже сами.

Также часто используется паттерн **синглтон**. С помощью него реализованы либо те объекты, которые должны существовать в единственной экземпляре, либо те, для которых нужно единственный раз загружать ресурсы. Один из примеров синглтона это класс **FixedSysFont**, мы лишь один раз подгружаем шрифт и пользуемся им каждый раз, когда выводим текст на экран, не загружая заново. Другим примером служит **ButtonsGroup**, которое может быть всего одно на экране.

Ещё идейно используется паттерн **команда** (только в группе геймплейных классов).
### Дополнительно
Можно протестировать работу боёвки в консоли следующим образом:
Откройте файл *core/src/com/mipt/tp/dungeon_sucker/DungeonSuckerGame.java*.
Найдите строчку:
`private static final boolean testFight = false;`
Установите значение поля *testFight* в true. То есть:
`private static final boolean testFight = true;`
### Основные ссылки
[https://libgdx.com/](https://libgdx.com/) - сайт основной сторонней библиотеки